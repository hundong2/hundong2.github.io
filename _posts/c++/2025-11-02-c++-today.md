---
title: "C++ - Compile-Time Dependency Injection (CTDI)"
date: 2025-11-02 21:02:52 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, Compile, Time, Dependency, Injection, (CTDI)]
---

## 오늘의 C++ 최신 기술 트렌드: **Compile-Time Dependency Injection (CTDI)**

**1. 간단한 설명:**

Compile-Time Dependency Injection (CTDI)는 런타임 오버헤드 없이 컴파일 시간에 의존성을 해결하는 기술입니다. traditional Dependency Injection (DI)는 일반적으로 런타임에 의존성을 주입하지만, CTDI는 템플릿 메타프로그래밍, `constexpr` 함수, Concepts 등을 활용하여 컴파일 시간에 의존성을 연결합니다.  이를 통해 성능 저하 없이 DI의 장점(테스트 용이성, 모듈성 향상)을 누릴 수 있으며, 특히 임베디드 시스템과 같이 성능이 중요한 환경에서 유용합니다. CTDI는 런타임 DI의 단점인 런타임 오버헤드를 제거하고 컴파일 타임에 오류를 감지하여 코드 안정성을 높입니다. 다양한 CTDI 구현 라이브러리들이 존재하며, 각 라이브러리마다 장단점이 있습니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **boost.hana:** 템플릿 메타프로그래밍 라이브러리로, CTDI 구현의 기반 기술을 제공합니다. (https://www.boost.org/doc/libs/1_83_0/libs/hana/doc/html/index.html)
*   **Various CTDI Implementation:** 다양한 CTDI 구현 라이브러리 및 관련 자료를 검색하여 비교 분석하는 것이 좋습니다. 예를 들어 GitHub에서 "C++ compile time dependency injection"으로 검색하면 다양한 오픈 소스 프로젝트를 찾을 수 있습니다.
*   **CppCon presentations:** CppCon과 같은 C++ 컨퍼런스에서 CTDI 관련 발표자료를 찾아볼 수 있습니다. (YouTube에서 "CppCon CTDI" 검색)

**3. 간단한 코드 예시 (C++):**

```cpp
#include <iostream>
#include <type_traits>

// Interface
template <typename T>
concept Logger = requires(T logger) {
    { logger.log(std::string{}) } -> std::same_as<void>;
};

// Concrete Logger Implementation
struct ConsoleLogger {
    void log(std::string message) {
        std::cout << "[ConsoleLogger] " << message << std::endl;
    }
};

// Another Logger Implementation
struct FileLogger {
    FileLogger(const std::string& filename) : filename_(filename) {}
    void log(std::string message) {
        std::cout << "[FileLogger] " << message << " to file: " << filename_ << std::endl;
    }
private:
    std::string filename_;
};

// Class that depends on a Logger (Compile-Time Dependency Injection)
template <Logger LoggerType>
class Application {
public:
    Application(LoggerType& logger) : logger_(logger) {}

    void run() {
        logger_.log("Application started.");
    }

private:
    LoggerType& logger_;
};


int main() {
    ConsoleLogger console_logger;
    FileLogger file_logger("app.log");

    Application<ConsoleLogger> app1(console_logger);
    app1.run(); // Uses ConsoleLogger

    Application<FileLogger> app2(file_logger);
    app2.run(); // Uses FileLogger

    return 0;
}
```

**4. 코드 실행 결과 예시:**

```
[ConsoleLogger] Application started.
[FileLogger] Application started. to file: app.log
```

**설명:**

위 예제에서는 `Logger`라는 Concept을 정의하여 로깅 기능을 추상화했습니다. `ConsoleLogger`와 `FileLogger`는 `Logger` Concept을 만족하는 구체적인 로거 구현체입니다. `Application` 클래스는 템플릿 매개변수를 통해 로거의 타입을 지정받고, 생성자를 통해 로거 객체에 대한 참조를 주입받습니다.  컴파일 시간에 `Application`의 템플릿 인자를 결정함으로써 런타임 오버헤드 없이 의존성을 해결합니다. main 함수에서는 `ConsoleLogger`와 `FileLogger`를 사용하여 `Application` 객체를 생성하고 실행하여 각각 다른 로거를 사용하는 것을 보여줍니다. 이를 통해 의존성을 컴파일 시간에 주입하여 런타임 오버헤드를 최소화하는 CTDI의 기본적인 개념을 확인할 수 있습니다.  더 복잡한 CTDI 라이브러리들은 템플릿 메타프로그래밍을 사용하여 의존성 그래프를 자동으로 분석하고 생성자 주입 등을 자동으로 처리할 수 있습니다.

