---
title: "C++ - Reflection with libclang"
date: 2025-10-23 21:03:06 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, Reflection, with, libclang]
---

## 오늘의 C++ 최신 기술 트렌드: **Reflection with libclang**

**1. 간단한 설명:**

`libclang`은 Clang 컴파일러의 C API를 제공하는 라이브러리입니다. 이를 사용하여 C++ 코드의 Abstract Syntax Tree (AST)에 접근하고, 타입 정보, 클래스 멤버, 함수 시그니처 등의 메타데이터를 추출할 수 있습니다.  최근에는 이 `libclang`을 활용하여 좀 더 정교하고 사용자 정의 가능한 리플렉션 시스템을 구축하는 사례가 늘고 있습니다.  기존의 Reflection TS에 비해 더 낮은 수준의 제어를 제공하지만, 컴파일 시간에 수행되는 코드 생성과 결합하여 강력한 기능을 구현할 수 있습니다.  특히,  Boost.Reflect와 같은 기존 리플렉션 라이브러리의 한계를 극복하고,  특정 도메인에 특화된 리플렉션 기반 도구를 개발하는 데 유용합니다. 주로 코드 생성, 직렬화, ORM, GUI 바인딩 등 다양한 영역에서 활용됩니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **libclang 공식 문서:** [https://clang.llvm.org/docs/LibASTMatchers.html](https://clang.llvm.org/docs/LibASTMatchers.html) (AST Matcher 부분에 주목)
*   **Clang AST Matcher Reference:** [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)
*   **Tutorial on libclang:** [https://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang](https://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang) ( 오래된 글이지만 핵심 원리 설명)
*   **코드 생성 및 리플렉션 관련 블로그 포스트 예시:** (검색어: "libclang reflection code generation")  구체적인 링크는 프로젝트 필요에 따라 검색하여 활용

**3. 간단한 코드 예시 (C++):**

```c++
#include <iostream>
#include <string>
#include <clang-c/Index.h>

// 에러 처리 함수
void error_handler(CXClientData client_data, CXDiagnostic diagnostic) {
    CXString string = clang_formatDiagnostic(diagnostic, clang_defaultDiagnosticDisplayOptions());
    fprintf(stderr, "%s\n", clang_getCString(string));
    clang_disposeString(string);
}

int main() {
    CXIndex index = clang_createIndex(0, 0);
    CXTranslationUnit translationUnit = clang_parseTranslationUnit(
        index,
        "test.cpp",  // 분석할 소스 파일 이름
        nullptr,     // 명령행 인자
        0,           // 명령행 인자 개수
        nullptr,     // include 파일 경로
        0,           // include 파일 경로 개수
        CXTranslationUnit_None // 파싱 옵션
    );

    if (translationUnit == nullptr) {
        std::cerr << "Translation unit 생성 실패" << std::endl;
        return 1;
    }

    // Diagnostic 처리기 설정 (에러 메시지 출력)
    clang_loadDiagnostics(translationUnit, nullptr, 0);
    CXDiagnosticSet diagnostics = clang_getTranslationUnitDiagnostics(translationUnit);
    unsigned numDiagnostics = clang_getNumDiagnosticsInSet(diagnostics);

    for (unsigned i = 0; i < numDiagnostics; ++i) {
        CXDiagnostic diagnostic = clang_getDiagnosticInSet(diagnostics, i);
        error_handler(nullptr, diagnostic);
        clang_disposeDiagnostic(diagnostic);
    }
    clang_disposeDiagnosticSet(diagnostics);



    CXCursor rootCursor = clang_getTranslationUnitCursor(translationUnit);

    // 커서 방문자 함수 (재귀적으로 AST 탐색)
    clang_visitChildren(
        rootCursor,
        [](CXCursor cursor, CXCursor parent, CXClientData client_data) {
            CXString cursorKindSpelling = clang_getCursorKindSpelling(clang_getCursorKind(cursor));
            CXString cursorSpelling = clang_getCursorSpelling(cursor);
            std::cout << "Cursor Kind: " << clang_getCString(cursorKindSpelling)
                      << ", Spelling: " << clang_getCString(cursorSpelling) << std::endl;
            clang_disposeString(cursorKindSpelling);
            clang_disposeString(cursorSpelling);
            return CXChildVisit_Recurse; // 자식 노드 방문
        },
        nullptr
    );

    clang_disposeTranslationUnit(translationUnit);
    clang_disposeIndex(index);

    return 0;
}
```

**test.cpp (분석 대상):**

```c++
#include <iostream>

class MyClass {
public:
    int myVariable;
    void myMethod(int arg) {
        std::cout << "Value: " << arg << std::endl;
    }
};

int main() {
    MyClass obj;
    obj.myVariable = 10;
    obj.myMethod(5);
    return 0;
}
```

**컴파일 및 실행 (Linux/macOS):**

```bash
g++ -std=c++17 test.cpp -o test
g++ -I/usr/lib/llvm-14/include -c main.cpp -o main.o  # clang 헤더 경로 설정 (LLVM 버전 맞춰야 함)
g++ main.o -o main -lclang

./main
```

**4. 코드 실행 결과 예시:**

```
Cursor Kind: CXCursorKind_TranslationUnit, Spelling:
Cursor Kind: CXCursorKind_UsingDirective, Spelling: std
Cursor Kind: CXCursorKind_Namespace, Spelling: std
Cursor Kind: CXCursorKind_ClassDecl, Spelling: MyClass
Cursor Kind: CXCursorKind_CXXAccessSpecifier, Spelling: public
Cursor Kind: CXCursorKind_FieldDecl, Spelling: myVariable
Cursor Kind: CXCursorKind_CXXAccessSpecifier, Spelling: public
Cursor Kind: CXCursorKind_FunctionDecl, Spelling: myMethod
Cursor Kind: CXCursorKind_ParmDecl, Spelling: arg
Cursor Kind: CXCursorKind_CompoundStmt, Spelling:
Cursor Kind: CXCursorKind_CallExpr, Spelling: cout
Cursor Kind: CXCursorKind_BinaryOperator, Spelling: <<
Cursor Kind: CXCursorKind_DeclStmt, Spelling: obj
Cursor Kind: CXCursorKind_ClassDecl, Spelling: MyClass
Cursor Kind: CXCursorKind_CXXAccessSpecifier, Spelling: public
Cursor Kind: CXCursorKind_FieldDecl, Spelling: myVariable
Cursor Kind: CXCursorKind_CXXAccessSpecifier, Spelling: public
Cursor Kind: CXCursorKind_FunctionDecl, Spelling: myMethod
Cursor Kind: CXCursorKind_ParmDecl, Spelling: arg
Cursor Kind: CXCursorKind_CompoundStmt, Spelling:
Cursor Kind: CXCursorKind_CallExpr, Spelling: cout
Cursor Kind: CXCursorKind_BinaryOperator, Spelling: <<
Cursor Kind: CXCursorKind_MemberRefExpr, Spelling: myVariable
Cursor Kind: CXCursorKind_CallExpr, Spelling: myMethod
Cursor Kind: CXCursorKind_IntegerLiteral, Spelling: 5
Cursor Kind: CXCursorKind_ReturnStmt, Spelling:
Cursor Kind: CXCursorKind_IntegerLiteral, Spelling: 0
```

**참고:**

*   위 예제는 기본적인 AST 탐색 방법을 보여줍니다. 실제 프로젝트에서는 더 복잡한 AST 매칭과 코드 생성을 수행해야 합니다.
*   `libclang`의 버전과 설치 경로는 시스템에 따라 다를 수 있습니다.  `-I` 옵션을 통해 정확한 include 경로를 지정해야 합니다.  LLVM과 Clang이 제대로 설치되어 있어야 합니다.
*   `test.cpp`를 컴파일러가 이해할 수 있도록 `-std=c++17` 등의 옵션을 사용하는 것이 좋습니다.
*   더욱 복잡한 AST 질의를 위해서는 `clang::ast_matchers` 라이브러리를 사용하는 것이 좋습니다. 이는 `libclang` C API보다 더 편리하고 강력한 API를 제공합니다. (하지만 C++ API 임)

이 기술은 C++ 메타프로그래밍의 한계를 극복하고,  더욱 강력하고 유연한 도구를 만들 수 있는 잠재력을 가지고 있습니다.

