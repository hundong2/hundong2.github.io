---
title: "C++ - Data-Oriented Design (DOD)"
date: 2025-08-30 21:02:58 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, Data, Oriented, Design, (DOD)]
---

## 오늘의 C++ 최신 기술 트렌드: **Data-Oriented Design (DOD)**

**1. 간단한 설명:**
Data-Oriented Design (DOD)은 객체 지향 프로그래밍(OOP)의 전통적인 접근 방식과는 달리, 데이터의 구조와 레이아웃이 프로그램 성능에 미치는 영향에 초점을 맞추는 프로그래밍 패러다임입니다.  DOD는 메모리 접근 패턴을 최적화하고 캐시 활용도를 높여 성능을 향상시키는 것을 목표로 합니다. 이는 대규모 데이터 처리, 게임 개발, 고성능 컴퓨팅 등에서 특히 중요합니다. DOD는 데이터의 변환을 최대한 효율적으로 수행하기 위해 데이터의 배치, 접근 방식, 알고리즘 선택 등을 신중하게 고려합니다.  OOP가 데이터에 대한 추상화를 제공하는 반면, DOD는 데이터 자체의 효율적인 처리에 집중합니다.  Entity Component System (ECS) 아키텍처는 DOD의 대표적인 구현 방식 중 하나입니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **Data-Oriented Design:** [https://dataorienteddesign.com/](https://dataorienteddesign.com/)
*   **Mike Acton's CPPCon Talk - Data-Oriented Design and C++:** [https://www.youtube.com/watch?v=rX0ItVEVjYI](https://www.youtube.com/watch?v=rX0ItVEVjYI)
*   **What is Data-Oriented Programming? | Robert Nystrom:** [https://web.archive.org/web/20231203201728/https://craftinginterpreters.com/data-oriented.html](https://web.archive.org/web/20231203201728/https://craftinginterpreters.com/data-oriented.html) (아카이브 링크)

**3. 간단한 코드 예시 (C++):**

```cpp
#include <iostream>
#include <vector>
#include <chrono>

// 구조체 배열 (Array of Structures - AOS) 방식
struct ParticleAOS {
    float x;
    float y;
    float z;
    float velocityX;
    float velocityY;
    float velocityZ;
};

// 배열 구조체 (Structure of Arrays - SOA) 방식
struct ParticleSOA {
    std::vector<float> x;
    std::vector<float> y;
    std::vector<float> z;
    std::vector<float> velocityX;
    std::vector<float> velocityY;
    std::vector<float> velocityZ;
};

void updateParticlesAOS(std::vector<ParticleAOS>& particles) {
    for (auto& p : particles) {
        p.x += p.velocityX;
        p.y += p.velocityY;
        p.z += p.velocityZ;
    }
}

void updateParticlesSOA(ParticleSOA& particles) {
    for (size_t i = 0; i < particles.x.size(); ++i) {
        particles.x[i] += particles.velocityX[i];
        particles.y[i] += particles.velocityY[i];
        particles.z[i] += particles.velocityZ[i];
    }
}

int main() {
    size_t numParticles = 100000;

    // AOS 초기화
    std::vector<ParticleAOS> particlesAOS(numParticles);
    for (size_t i = 0; i < numParticles; ++i) {
        particlesAOS[i].x = i;
        particlesAOS[i].y = i;
        particlesAOS[i].z = i;
        particlesAOS[i].velocityX = 1.0f;
        particlesAOS[i].velocityY = 1.0f;
        particlesAOS[i].velocityZ = 1.0f;
    }

    // SOA 초기화
    ParticleSOA particlesSOA;
    particlesSOA.x.resize(numParticles);
    particlesSOA.y.resize(numParticles);
    particlesSOA.z.resize(numParticles);
    particlesSOA.velocityX.resize(numParticles);
    particlesSOA.velocityY.resize(numParticles);
    particlesSOA.velocityZ.resize(numParticles);

    for (size_t i = 0; i < numParticles; ++i) {
        particlesSOA.x[i] = i;
        particlesSOA.y[i] = i;
        particlesSOA.z[i] = i;
        particlesSOA.velocityX[i] = 1.0f;
        particlesSOA.velocityY[i] = 1.0f;
        particlesSOA.velocityZ[i] = 1.0f;
    }

    // AOS 성능 측정
    auto startAOS = std::chrono::high_resolution_clock::now();
    updateParticlesAOS(particlesAOS);
    auto endAOS = std::chrono::high_resolution_clock::now();
    auto durationAOS = std::chrono::duration_cast<std::chrono::microseconds>(endAOS - startAOS);

    // SOA 성능 측정
    auto startSOA = std::chrono::high_resolution_clock::now();
    updateParticlesSOA(particlesSOA);
    auto endSOA = std::chrono::high_resolution_clock::now();
    auto durationSOA = std::chrono::duration_cast<std::chrono::microseconds>(endSOA - startSOA);

    std::cout << "AOS Duration: " << durationAOS.count() << " microseconds" << std::endl;
    std::cout << "SOA Duration: " << durationSOA.count() << " microseconds" << std::endl;

    return 0;
}
```

**4. 코드 실행 결과 예시:**

```
AOS Duration: 1234 microseconds
SOA Duration: 789 microseconds
```

(실제 실행 결과는 환경에 따라 크게 달라질 수 있습니다. SOA 방식이 캐시 효율성 덕분에 일반적으로 더 빠른 성능을 보입니다.)

**설명:** 위 예제는 AOS(Array of Structures)와 SOA(Structure of Arrays) 두 가지 방식으로 파티클 데이터를 저장하고 업데이트하는 간단한 시뮬레이션을 보여줍니다. AOS는 각 파티클의 데이터를 연속적인 메모리 블록에 저장하는 반면, SOA는 동일한 속성의 데이터를 연속적인 메모리 블록에 저장합니다. SOA 방식은 메모리 접근 패턴을 최적화하여 캐시 활용도를 높여 성능을 향상시킬 수 있습니다.  실제 결과는 CPU의 캐시 크기, 컴파일러 최적화 수준, 다른 실행 중인 프로세스 등에 따라 달라질 수 있습니다. 일반적으로 SOA가 특정 시뮬레이션 또는 데이터 처리 워크로드에서 성능 이점을 제공하는 경향이 있습니다.

