---
title: "C++ - C++26의 Executors"
date: 2025-10-30 21:03:43 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, C++26의, Executors]
---

## 오늘의 C++ 최신 기술 트렌드: **C++26의 Executors**

**1. 간단한 설명:**

C++26에 도입될 예정인 Executors는 비동기 및 병렬 프로그래밍을 위한 표준 인터페이스를 제공합니다. Executors는 작업(tasks)을 실행할 수 있는 컴퓨팅 리소스를 추상화하여, 프로그래머가 실행 전략(예: 스레드 풀, GPU, 원격 서버)에 대한 구체적인 구현 세부 사항에 신경 쓰지 않고도 작업을 제출할 수 있도록 합니다.  이는 코드의 이식성, 유연성 및 유지 보수성을 크게 향상시킵니다. 또한, Executors는 P2300 std::execution을 기반으로 하며, Cancellation Tokens과 함께 사용하여 작업의 취소를 용이하게 합니다.  이는 복잡한 비동기 시스템에서 매우 중요합니다.  Executors는 C++의 동시성 프로그래밍을 크게 단순화하고 효율적으로 만들 잠재력을 가지고 있습니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

* **P2300 std::execution:** (현재 Executors의 기반) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2300r6.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2300r6.html)
* **N4991: Working Draft, Standard for Programming Language C++ (Executors 관련 내용):** [https://eel.is/c++draft/executors](https://eel.is/c++draft/executors)
* **CppCon 강연 (Executor 관련 내용):** CppCon과 같은 컨퍼런스에서 Executors에 대한 강연을 찾아보는 것도 좋습니다. YouTube에서 "CppCon executors"로 검색하면 관련 자료를 찾을 수 있습니다.

**3. 간단한 코드 예시 (C++):**

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <vector>
// 간단한 Executor 예시 (실제 구현은 더 복잡함)
class ThreadPoolExecutor {
public:
    ThreadPoolExecutor(size_t num_threads) : pool(num_threads) {}

    template <typename F, typename... Args>
    auto submit(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type> {
        using ReturnType = typename std::result_of<F(Args...)>::type;
        auto task = std::packaged_task<ReturnType(void)>(std::bind(std::forward<F>(f), std::forward<Args>(args)...));
        std::future<ReturnType> future = task.get_future();
        {
            std::lock_guard<std::mutex> lock(queue_mutex);
            task_queue.push(std::move(task));
        }
        condition.notify_one();
        return future;
    }

    ~ThreadPoolExecutor() {
      stop = true;
      condition.notify_all();
      for(std::thread& worker : pool) {
        worker.join();
      }
    }

private:
    std::vector<std::thread> pool;
    std::queue<std::packaged_task<void()>> task_queue;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop = false;


    ThreadPoolExecutor(const ThreadPoolExecutor&) = delete;
    ThreadPoolExecutor& operator=(const ThreadPoolExecutor&) = delete;

    ThreadPoolExecutor(ThreadPoolExecutor&&) = delete;
    ThreadPoolExecutor& operator=(ThreadPoolExecutor&&) = delete;

    void worker_thread() {
      while (true) {
        std::packaged_task<void()> task;
        {
          std::unique_lock<std::mutex> lock(queue_mutex);
          condition.wait(lock, [this]{ return stop || !task_queue.empty(); });
          if (stop && task_queue.empty())
              return;
          task = std::move(task_queue.front());
          task_queue.pop();
        }
        task();
      }
    }

  public:
  ThreadPoolExecutor(ThreadPoolExecutor const&) = delete;
  ThreadPoolExecutor& operator=(ThreadPoolExecutor const&) = delete;
  ThreadPoolExecutor(ThreadPoolExecutor&&) = delete;
  ThreadPoolExecutor& operator=(ThreadPoolExecutor&&) = delete;

private:
    std::vector<std::thread> pool = [&] () {
        std::vector<std::thread> threads;
        threads.reserve(num_threads);
        for(size_t i = 0; i < num_threads; ++i) {
            threads.emplace_back([this] { this->worker_thread(); });
        }
        return threads;
    }();

};

int main() {
    ThreadPoolExecutor executor(4); // 4개의 스레드를 가진 Executor 생성

    auto future1 = executor.submit([](int a, int b) {
        std::cout << "Task 1 실행 중... a + b = " << a + b << std::endl;
        return a + b;
    }, 10, 20);

    auto future2 = executor.submit([]() {
        std::cout << "Task 2 실행 중..." << std::endl;
        return "Task 2 완료";
    });

    auto result1 = future1.get();
    auto result2 = future2.get();

    std::cout << "Task 1 결과: " << result1 << std::endl;
    std::cout << "Task 2 결과: " << result2 << std::endl;

    return 0;
}
```

**4. 코드 실행 결과 예시:**

```
Task 1 실행 중... a + b = 30
Task 2 실행 중...
Task 1 결과: 30
Task 2 결과: Task 2 완료
```

**참고:** 위 코드는 단순한 ThreadPoolExecutor 예시이며, C++26 Executors 표준은 훨씬 더 유연하고 확장 가능한 인터페이스를 제공합니다.  표준 Executor는 ThreadPoolExecutor 외에도 다른 종류의 실행 환경 (예: GPU, 원격 서버)을 지원하도록 설계되었습니다.  또한, 표준 Executor는 std::execution::scheduler를 통해 작업 예약에 대한 더 많은 제어를 제공합니다.  실제 Executors의 사용법은 표준이 확정된 후에 더 명확해질 것입니다.

