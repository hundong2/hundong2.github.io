---
title: "C++ - C++23의 std::move_only_function"
date: 2025-08-13 21:03:02 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, C++23의, std::move_only_function]
---

## 오늘의 C++ 최신 기술 트렌드: **C++23의 std::move_only_function**

**1. 간단한 설명:**

`std::move_only_function`은 복사 생성자와 복사 대입 연산자를 명시적으로 삭제하여 이동만 가능한 함수 객체를 캡슐화하는 새로운 기능입니다. 이는 C++11의 `std::function`의 제한 사항을 해결하고, 상태를 공유하지 않거나 복사 비용이 높은 함수 객체(예: 파일 핸들, 뮤텍스 등을 소유한 람다)를 더욱 효율적으로 다룰 수 있도록 합니다. `std::function`은 내부적으로 타입 소거(Type Erasure)를 사용하지만, 복사 가능한 함수 객체를 가정하기 때문에 이동만 가능한 객체를 직접 담을 수 없습니다. `std::move_only_function`은 이러한 제약을 극복하여, 보다 유연하고 안전한 콜백 및 이벤트 핸들러 구현을 가능하게 합니다. 특히, 비동기 프로그래밍, 리소스 관리, 그리고 RAII 패턴을 강화하는 데 유용합니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **cppreference.com:** (C++23이므로 아직 정식 문서가 없을 수 있지만, 일반적으로 최신 정보가 빠르게 업데이트됩니다.) `std::move_only_function`에 대한 자료가 올라오는지 확인해보세요.
*   **P0288R9 - move_only_function:**  `std::move_only_function`의 제안서.  이 문서를 통해 설계 의도와 사용법을 자세히 알 수 있습니다: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p3042r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p3042r0.html)
*   **C++ Standards Committee:** 공식 웹사이트에서 C++23 관련 최신 정보를 확인하세요.

**3. 간단한 코드 예시 (C++):**

```cpp
#include <iostream>
#include <functional>
#include <memory>

class MyResource {
public:
    MyResource(int id) : id_(id) {
        std::cout << "Resource " << id_ << " acquired." << std::endl;
    }
    ~MyResource() {
        std::cout << "Resource " << id_ << " released." << std::endl;
    }

    MyResource(const MyResource&) = delete;
    MyResource& operator=(const MyResource&) = delete;

    MyResource(MyResource&&) = default;
    MyResource& operator=(MyResource&&) = default;


    void use() {
        std::cout << "Using resource " << id_ << std::endl;
    }

private:
    int id_;
};

int main() {
    // 이동 전용 리소스를 캡처하는 람다
    auto resource = std::make_unique<MyResource>(1);

    std::move_only_function<void()> func = [resource = std::move(resource)]() mutable {
        if (resource) {
          resource->use();
        }
    };

    // 함수 실행
    func();

    // func는 소멸될 때 resource를 해제합니다.
    return 0;
}
```

**4. 코드 실행 결과 예시:**

```
Resource 1 acquired.
Using resource 1
Resource 1 released.
```

**설명:**

이 예제에서 `MyResource` 클래스는 복사 불가능하고 이동만 가능한 리소스를 나타냅니다. 람다 함수는 `std::unique_ptr`을 사용하여 리소스를 캡처하고, `std::move_only_function`에 저장됩니다. `std::move_only_function`은 람다를 호출하여 리소스를 사용하고, 함수가 범위를 벗어나면 리소스가 안전하게 해제됩니다. 이를 통해 이동 전용 리소스를 사용하는 람다 함수를 안전하게 관리할 수 있으며, RAII의 장점을 활용할 수 있습니다.  `std::function`으로는 `std::unique_ptr`을 복사할 수 없으므로, 위와 같은 코드를 작성할 수 없습니다.

