---
title: "C++ - C++26의 Networking TS"
date: 2025-09-17 21:03:27 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, C++26의, Networking, TS]
---

## 오늘의 C++ 최신 기술 트렌드: **C++26의 Networking TS**

**1. 간단한 설명:**
C++26에 포함될 것으로 예상되는 Networking Technical Specification은 C++ 표준 라이브러리에 현대적인 비동기 네트워킹 기능을 통합하는 것을 목표로 합니다.  boost::asio를 기반으로 하며, 코루틴과의 통합을 통해 비동기 프로그래밍을 더욱 쉽고 효율적으로 만들고, 다양한 네트워크 프로토콜 (TCP, UDP, SSL/TLS 등)에 대한 지원을 제공하여 네트워킹 개발 생산성을 높입니다.  Non-blocking I/O, 콜백 기반 프로그래밍의 복잡성을 줄이고,  모던 C++ 디자인 원칙을 따릅니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **Networking TS 공식 문서 (현재 working draft):**  [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4961.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4961.pdf) (가장 최신 Draft)
*   **Boost.Asio:** [https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio.html](https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio.html) (Networking TS의 기반이 되는 라이브러리)
*   **CppCon 2023 발표 자료:**  (CppCon에서 Networking TS 관련 발표가 있을 수 있으며, YouTube에서 검색을 통해 자료를 찾아볼 수 있습니다. 예를 들어, "CppCon 2023 Networking TS" 등으로 검색해 보세요.)

**3. 간단한 코드 예시 (C++):**

아래 코드는 Networking TS를 사용하여 간단한 TCP 에코 서버를 구현하는 예시입니다.  **주의:** Networking TS는 아직 표준에 완전히 포함되지 않았으므로, 컴파일러 지원 및 헤더 파일 이름이 달라질 수 있습니다. 아래 코드는 개념적인 예시이며, 실제 컴파일 및 실행을 위해서는 Networking TS 구현체를 사용해야 합니다.

```cpp
#include <iostream>
#include <net> //  <experimental/net> 또는 <asio> 로 변경될 수 있음

#include <coroutine>

using namespace std;

namespace net = std::net;  // 또는 experimental::net 또는 asio로 변경될 수 있음

net::awaitable<void> echo(net::tcp::socket socket) {
  try {
    char data[1024];
    while (true) {
      std::size_t n = co_await socket.async_read_some(net::buffer(data), net::use_awaitable);
      co_await net::async_write(socket, net::buffer(data, n), net::use_awaitable);
    }
  } catch (const std::exception& e) {
    std::cerr << "Exception in echo: " << e.what() << std::endl;
  }
}

net::awaitable<void> listener() {
  net::io_context ioc;
  net::tcp::acceptor acceptor(ioc, {net::ip::make_address("127.0.0.1"), 12345});

  while (true) {
    net::tcp::socket socket = co_await acceptor.async_accept(net::use_awaitable);
    co_await echo(std::move(socket)); // 코루틴으로 처리
  }
}

int main() {
    net::io_context ioc;
    net::co_spawn(ioc, listener(), net::detached); // 코루틴 시작
    ioc.run();
    return 0;
}
```

**4. 코드 실행 결과 예시:**

위 코드 실행 결과는 다음과 같습니다.

1.  서버가 127.0.0.1 주소의 12345 포트에서 연결을 대기합니다.
2.  클라이언트가 서버에 연결되면, 서버는 클라이언트로부터 받은 데이터를 다시 클라이언트로 Echo합니다.
3.  `net::io_context::run()`은 이벤트 루프를 실행하여 비동기 작업을 처리합니다.
4.  `co_spawn` 함수는 `listener` 코루틴을 실행하고, `net::detached`는 코루틴이 완료될 때까지 기다리지 않고 분리합니다.

**주의:** 위 코드는 개념적인 예시이며, 실제 Networking TS 구현체를 사용하여 컴파일 및 실행해야 합니다.  아직 표준으로 확정되지 않았으므로, 구현체의 API가 변경될 수 있습니다.  또한, 컴파일을 위해서는 해당 Networking TS 구현체를 컴파일러에 링크해야 합니다. Boost.Asio를 기반으로 구현체를 직접 만들 수도 있습니다.

