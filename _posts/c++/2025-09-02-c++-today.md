---
title: "C++ - Concurrent Data Structures with Hazard Pointers"
date: 2025-09-02 21:03:05 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, Concurrent, Data, Structures, with, Hazard, Pointers]
---

## 오늘의 C++ 최신 기술 트렌드: **Concurrent Data Structures with Hazard Pointers**

**1. 간단한 설명:**
Hazard Pointers는 lock-free (락이 없는) 동시성 데이터 구조를 구현하는 데 사용되는 메모리 관리 기술입니다. 가비지 컬렉션이 없는 환경에서 안전하게 객체를 삭제하는 방법을 제공합니다. 여러 스레드가 동시에 데이터 구조에 접근하고 수정할 때 데이터 경쟁과 메모리 누수를 방지하는 데 도움이 됩니다. 기본적인 아이디어는 스레드가 삭제될 수 있는 객체를 접근하기 전에 "hazard pointer"를 설정하여 해당 객체가 사용 중임을 표시하는 것입니다. 삭제 작업은 해당 객체가 어떤 hazard pointer에도 걸려있지 않을 때만 안전하게 수행됩니다. 이는 reference counting과 유사하지만, 순환 참조 문제를 해결할 수 있습니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **Herb Sutter - Lock-Free Data Structures via Hazard Pointers:** [https://herbsutter.com/2019/01/01/lock-free-data-structures-via-hazard-pointers-part-1/](https://herbsutter.com/2019/01/01/lock-free-data-structures-via-hazard-pointers-part-1/) (Herb Sutter의 시리즈 강좌)
*   **CppCon 2015: Herb Sutter "Lock-Free Programming (or, Juggling Razor Blades)":** [https://www.youtube.com/watch?v=xHjw9L_4ZtU](https://www.youtube.com/watch?v=xHjw9L_4ZtU) (Hazard Pointers에 대한 언급 포함)
*   **Boost.Lockfree:** [https://www.boost.org/doc/libs/1_85_0/doc/html/lockfree.html](https://www.boost.org/doc/libs/1_85_0/doc/html/lockfree.html) (Boost 라이브러리의 lock-free 자료 구조, Hazard Pointer 구현을 활용할 수 있음)

**3. 간단한 코드 예시 (C++):**

```c++
#include <iostream>
#include <atomic>
#include <thread>
#include <vector>

// 간단한 Hazard Pointer 예시 (완전한 lock-free 자료구조 구현은 아님)
template <typename T>
class HazardPointer {
public:
    HazardPointer() : ptr_(nullptr) {}

    T load() const {
        return ptr_.load(std::memory_order_acquire);
    }

    void store(T ptr) {
        ptr_.store(ptr, std::memory_order_release);
    }

private:
    std::atomic<T> ptr_;
};

// Hazard Pointer 관리자 (전역적으로 관리)
class HazardPointerManager {
public:
    static HazardPointerManager& getInstance() {
        static HazardPointerManager instance;
        return instance;
    }

    HazardPointer<void*> acquire() {
        // 실제 구현에서는 가용한 Hazard Pointer를 재사용해야 함
        return HazardPointer<void*>();
    }

    void release(HazardPointer<void*>& hazard_ptr) {
        // 실제 구현에서는 Hazard Pointer를 재사용 가능하게 해야 함
        hazard_ptr.store(nullptr);
    }

private:
    HazardPointerManager() {} // Singleton
    HazardPointerManager(const HazardPointerManager&) = delete;
    HazardPointerManager& operator=(const HazardPointerManager&) = delete;
};


struct Node {
  int data;
  std::atomic<Node*> next;
};

int main() {
  Node* node1 = new Node{1, nullptr};
  Node* node2 = new Node{2, nullptr};
  node1->next.store(node2, std::memory_order_release);

  // 스레드에서 노드에 접근하는 예시
  std::thread t([&]() {
    HazardPointer<void*> hazard_ptr = HazardPointerManager::getInstance().acquire();
    hazard_ptr.store(node1);  // Hazard Pointer 설정
    Node* current = static_cast<Node*>(hazard_ptr.load()); // 타입 캐스팅
    if (current != nullptr) {
      std::cout << "Data: " << current->data << std::endl;
    }
    HazardPointerManager::getInstance().release(hazard_ptr); // Hazard Pointer 해제
  });

  t.join();

  // 실제 구현에서는 안전하게 삭제하기 위한 deferred deletion 메커니즘이 필요
  delete node1;
  delete node2;

  return 0;
}
```

**4. 코드 실행 결과 예시:**

```
Data: 1
```

**설명:**

*   이 코드는 완전한 lock-free 데이터 구조를 구현하는 것이 아니라 Hazard Pointer의 기본적인 개념을 보여주는 간단한 예시입니다.
*   실제 lock-free 자료 구조에서는 더 복잡한 메모리 관리 및 동기화 메커니즘이 필요합니다.
*   `HazardPointerManager`는 Hazard Pointer의 풀을 관리하고, 스레드가 사용 중인 객체를 삭제하지 않도록 보장합니다.  실제 구현에서는 Hazard Pointer 재사용을 위한 로직이 필요합니다.
*   `acquire()` 함수는 사용 가능한 Hazard Pointer를 반환하고, `release()` 함수는 사용이 끝난 Hazard Pointer를 다시 풀에 반환합니다.
*   스레드는 객체에 접근하기 전에 Hazard Pointer를 설정하고, 사용이 끝나면 Hazard Pointer를 해제합니다.
*   **중요:**  실제 lock-free 구현에서는 삭제된 객체를 재사용하는 것을 방지하기 위해 `deferred deletion` (지연 삭제) 메커니즘이 필요합니다. 객체를 즉시 삭제하는 대신, 삭제할 객체 목록에 추가하고, Hazard Pointer에 걸려있지 않을 때만 안전하게 삭제합니다.
*   이 예제는 설명을 위해 `void*`를 사용했지만, 실제 코드에서는 형 안전성을 위해 템플릿을 사용하는 것이 좋습니다.
*   Boost.Lockfree 라이브러리는 Hazard Pointer를 포함한 다양한 lock-free 자료 구조를 제공하므로, 이를 활용하는 것이 좋습니다.
*  코드 예시는 설명을 위한 최소한의 예시이므로, 실제 lock-free 자료구조를 구축하려면 훨씬 더 복잡한 로직과 동기화 메커니즘이 필요합니다.  특히 ABA 문제를 해결하기 위한 메커니즘도 고려해야 합니다.

