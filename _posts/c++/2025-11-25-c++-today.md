---
title: "C++ - P2973R1: static containers"
date: 2025-11-25 21:03:42 +0900
categories: c++
tags: [c++, 최신기술, 추천, C++, P2973R1:, static, containers]
---

## 오늘의 C++ 최신 기술 트렌드: **P2973R1: static containers**

**1. 간단한 설명:**

P2973R1은 컴파일 시간에 크기를 알고 있는 컨테이너를 정의하는 방법을 제시합니다. 이는 `std::array`와 유사하지만, 더 큰 유연성을 제공하며, 컴파일 시간에 초기화된 데이터와 함께 사용할 수 있도록 설계되었습니다.  핵심 목표는 컴파일 시간에 모든 데이터가 결정되는 경우, 런타임 오버헤드를 없애는 것입니다. 기존 `std::array`의 제한 사항 (특히 집계 초기화 제한)을 해결하고, constexpr 함수 내에서 사용하기 더 용이하게 만드는 것이 목표입니다.  이를 통해 임베디드 시스템, 게임 개발, 고성능 컴퓨팅 등 런타임 성능이 중요한 분야에서 큰 이점을 얻을 수 있습니다.  `static_vector`와 같은 컨테이너를 컴파일 시간에 생성하고 사용할 수 있게 됩니다.

**2. 참고할 만한 공식 사이트나 블로그 링크:**

*   **제안서 원문:** [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2973r1.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2973r1.pdf)
*   **cppalliance 관련 논의:** 아마존의 리포지토리에서 논의중임 (https://github.com/cppalliance/lwg-sandbox/issues/16)

**3. 간단한 코드 예시 (C++):**

P2973R1은 표준으로 완전히 구현되지는 않았지만, 다음과 유사한 코드를 상상해 볼 수 있습니다.  (다만, 실제 사용 가능한 코드는 컴파일러 지원 상황에 따라 다릅니다.)

```cpp
#include <algorithm>

template <typename T, size_t N>
struct static_vector {
  T data[N];
  size_t size = 0;

  constexpr static_vector() : size(0) {}

  constexpr void push_back(const T& value) {
    if (size < N) {
      data[size] = value;
      ++size;
    }
  }

  constexpr T operator[](size_t index) const {
    return data[index];
  }

  constexpr size_t get_size() const { return size; }

  template<typename Func>
  constexpr void transform(Func f) {
    for (size_t i = 0; i < size; ++i) {
      data[i] = f(data[i]);
    }
  }
};

constexpr static_vector<int, 3> create_vector() {
  static_vector<int, 3> vec;
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  return vec;
}

constexpr auto my_vector = create_vector();

int main() {
  static_assert(my_vector[0] == 1);
  static_assert(my_vector.get_size() == 3);

  static_vector<int, 3> another_vector;
  another_vector.push_back(4);
  another_vector.push_back(5);
  another_vector.push_back(6);

  another_vector.transform([](int x) { return x * 2; });

  static_assert(another_vector[0] == 8);
  static_assert(another_vector[1] == 10);
  static_assert(another_vector[2] == 12);
}
```

**4. 코드 실행 결과 예시:**

위 코드는 컴파일 시간에 `my_vector`를 초기화하고, `static_assert`를 통해 컴파일 시간에 값을 검증합니다.  만약 `static_assert`가 실패하면 컴파일 오류가 발생합니다. 실제 실행 시에는 별도의 출력이 없습니다. 중요한 점은 `my_vector`는 컴파일 시간에 생성 및 사용되므로, 런타임 오버헤드가 없다는 것입니다.  `another_vector`의 경우, transform 함수를 constexpr로 구현하여 컴파일 타임에 실행될 수도 있습니다. 이 경우도 런타임 오버헤드는 없습니다. 만약 transform이 constexpr이 아니라면 런타임에 실행됩니다.

